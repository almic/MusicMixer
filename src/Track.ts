import AudioSource from './AudioSource';

type TrackBeat = {
    time: number;
    isCancelled: boolean;

    /**
     * Cancels future beat events generated by this TrackBeat on a best-case basis.
     *
     * If the beat event was already scheduled, it may cause third-party listeners to be called anyway.
     * Tracks will always double-check that the TrackBeat they synchronized to was still active at the time,
     * rapidly stopping playback. In the worst case, a synchronized track may be audible for a brief moment.
     */
    cancel(): void;
};

enum TrackEventType {
    START_PLAYBACK = 'startPlayback',
    STOP_PLAYBACK = 'stopPlayback',
    BEAT = 'beat',
    POSITION = 'position',
    SILENCED = 'silenced',
}

/**
 * Adjustment options to use when changing volume, panning, etc.
 *
 * When swapping two audio sources on a single track, `swap` and `swapDelay` are used to determine the swap
 * order and delay between the two audio sources.
 */
export type AdjustmentOptions = {
    ramp?: 'linear' | 'exponential' | 'natural' | number[];
    delay?: number;
    duration?: number;

    /**
     * Order of operation when swapping sources on a track via start() and playSource().
     *
     * - `rampInOut`: ramps in the new source, waits `swapDelay`, then ramps out the old source
     * - `rampOutIn`: ramps out the old source, waits `swapDelay`, then ramps in the new source
     * - `rampCross`: ramps both sources at the same time, ignoring `swapDelay`
     * - `cut`: instantly stops the old source and starts the new source with sub-sample precision
     */
    swap?: 'rampInOut' | 'rampOutIn' | 'rampCross' | 'cut';

    /**
     * Time to wait between actions for `rampInOut` and `rampOutIn` swapping.
     *
     * Only when swapping audio sources on a track via start() and playSource().
     */
    swapDelay?: number;
};

/**
 * Track interface
 */
interface Track {
    /**
     * Begin playback on the track.
     *
     * If both `delay` and `options.delay` are provided, they are added together.
     * @param delay optional delay time
     * @param options adjustment parameters
     */
    start(delay?: number, options?: AdjustmentOptions): Track;

    /**
     * Stop playback on the track.
     *
     * If both `delay` and `options.delay` are provided, they are added together.
     * @param delay optional delay time
     * @param options adjustment parameters
     */
    stop(delay?: number, options?: AdjustmentOptions): Track;

    /**
     * Loads and immediately starts playback of an audio source. If there is already an audio source
     * playing, once the new one is loaded, it will be stopped and the new source will start.
     * @param path audio source path
     * @param options adjustment parameters
     */
    playSource(path: string, options?: AdjustmentOptions): AudioSource;

    /**
     * Loads an audio source and returns it. The audio source will be linked to this track, so that
     * calling `start()` will play the last loaded audio source. You may use this to load a second
     * audio source while one is already playing, it will not be swapped until a call to `start()`
     * is made.
     * @param path audio source path
     */
    loadSource(path: string): AudioSource;

    /**
     * Set the volume of this track.
     * @param volume gain percentage
     * @param options adjustment parameters
     */
    volume(volume: number, options?: AdjustmentOptions): Track;

    /**
     * Enabled/ disable a loop, and set timings.
     * @param enabled true to enable looping
     * @param startSample point to loop back to
     * @param endSample trigger point for the loop
     */
    loop(enabled: boolean, startSample?: number, endSample?: number): Track;

    /**
     * Enable/ disable a jump, and set timings.
     * @param enabled true to enable jumping
     * @param fromSample trigger point for the jump
     * @param toSample point to jump to
     */
    jump(enabled: boolean, fromSample?: number, toSample?: number): Track;

    /**
     * Create a beat rule and return it.
     *
     * Calling multiple times will stack beat rules. Use sparingly!
     * Returned TrackBeat can be used to cancel it later.
     * @param type beat type, can be 'repeating' | 'precise' | 'exclude'
     * @param origin origin point for this beat or range
     * @param period duration (exclude) or period (repeating), or does nothing (precise)
     */
    createBeat(type: 'repeating' | 'precise' | 'exclude', origin: number, period?: number): TrackBeat;

    /**
     * Clears all beats on this track and cancels them
     */
    clearBeats(): Track;

    /**
     * Schedules this track to start playback precisely when the given track generates a beat.
     * @param track track
     * @param options adjustment parameters
     */
    syncPlayTo(track: Track, options?: AdjustmentOptions): Track;

    /**
     * Schedules this track to stop playback precisely when the given track generates a beat.
     *
     * It is possible to synchronize a track to stop to itself.
     * @param track track
     * @param options adjustment parameters
     */
    syncStopTo(track: Track, options?: AdjustmentOptions): Track;

    /**
     * Assigns a callback to be called for the event. The first arguement is always the calling track.
     *
     * Signatures are:
     *
     * - `startPlayback(track, startOptions)` => ({@link Track}, {@link AdjustmentOptions})
     * - `stopPlayback(track, stopOptions)` => ({@link Track}, {@link AdjustmentOptions})
     * - `beat(track, beat)` => ({@link Track}, {@link TrackBeat})
     * - `position(track, time)` => ({@link Track}, `number`)
     * - `silenced(track, time)` => ({@link Track}, `number`)
     *
     * @param type event to listen for
     * @param callback async function to execute
     */
    listenFor(type: TrackEventType, callback: Promise<any>): Track;
}

/**
 * Track implementation
 */
class TrackSingle implements Track {
    private readonly gainNode: GainNode;

    constructor(
        private readonly name: string,
        private readonly audioContext: AudioContext,
        readonly destination: AudioNode,
        private readonly source: AudioSource,
    ) {
        this.gainNode = audioContext.createGain();
        this.gainNode.connect(destination);
        source.connect(this.gainNode);
    }

    toString(): string {
        return `TrackSingle[${this.name}] with context ${this.audioContext} and source ${this.source}`;
    }

    start(delay?: number, options?: AdjustmentOptions): Track {
        console.log(`stub start with ${delay} seconds of delay with options ${options}`);
        return this;
    }

    stop(delay?: number, options?: AdjustmentOptions): Track {
        console.log(`stub stop with ${delay} seconds of delay with options ${options}`);
        return this;
    }

    playSource(path: string, options?: AdjustmentOptions): AudioSource {
        console.log(`stub playSource at ${path} with ${options}`);
        return new AudioSource();
    }

    loadSource(path: string): AudioSource {
        console.log(`stub loadSource at ${path}`);
        return new AudioSource();
    }

    volume(volume: number, options?: AdjustmentOptions): Track {
        console.log(`stub volume changed to ${volume} with ${options}`);
        return this;
    }

    loop(enabled: boolean, startSample?: number, endSample?: number): Track {
        console.log(`stub loop ${enabled} in range ${startSample} to ${endSample}`);
        return this;
    }

    jump(enabled: boolean, fromSample?: number, toSample?: number): Track {
        console.log(`stub jump ${enabled} from ${fromSample} to ${toSample}`);
        return this;
    }

    createBeat(type: 'repeating' | 'precise' | 'exclude', origin: number, period?: number): TrackBeat {
        console.log(`stub createBeat of ${type} at ${origin} with period ${period}`);
        return { time: 0, isCancelled: false, cancel: () => {} };
    }

    clearBeats(): Track {
        console.log('stub clearBeats');
        return this;
    }

    syncPlayTo(track: Track, options?: AdjustmentOptions): Track {
        console.log(`stub syncPlayTo ${track} with options ${options}`);
        return this;
    }

    syncStopTo(track: Track, options?: AdjustmentOptions): Track {
        console.log(`stub syncStopTo ${track} with options ${options}`);
        return this;
    }

    listenFor(type: TrackEventType, callback: Promise<any>): Track {
        console.log(`stub listenFor ${type} calling ${callback}`);
        return this;
    }
}

/**
 * TrackGroup
 */
class TrackGroup implements Track {
    private tracks: {
        [name: string]: Track;
    } = {};

    private readonly gainNode: GainNode;

    constructor(
        private readonly name: string,
        private readonly audioContext: AudioContext,
        readonly destination: AudioNode,
        private readonly source: AudioSource,
    ) {
        this.gainNode = audioContext.createGain();
        this.gainNode.connect(destination);

        const track = new TrackSingle(name, audioContext, this.gainNode, source);
        this.tracks[name] = track;
    }

    toString(): string {
        return `TrackGroup[${this.name}] with context ${this.audioContext} and source ${this.source}`;
    }

    track(name: string): Track | undefined {
        return this.tracks[name];
    }

    primaryTrack(): Track {
        return this.tracks[this.name] as Track;
    }

    /**
     * Add a new track to this group.
     * @param name name of the track
     * @param path path to audio source
     * @param source loaded audio source
     */
    newTrack(name: string, path?: string, source?: AudioSource): Track {
        if (name == this.name) {
            throw new Error(`Cannot use name "${name}" as it is the name of this group track`);
        }
        if (Object.keys(this.tracks).includes(name)) {
            throw new Error(`Cannot use name "${name}" as it already exists in this group track`);
        }
        let audioSource = source;
        if (!audioSource) {
            audioSource = new AudioSource();
            if (path) {
                audioSource.load(path);
            }
        }
        const track = new TrackSingle(name, this.audioContext, this.gainNode, audioSource);
        this.tracks[name] = track;
        return track;
    }

    /**
     * Starts playback of all tracks in this group.
     */
    start(delay?: number, options?: AdjustmentOptions): Track {
        for (const track in this.tracks) {
            this.tracks[track]?.start(delay, options);
        }
        return this;
    }

    /**
     * Stops playback of all tracks in this group.
     */
    stop(delay?: number, options?: AdjustmentOptions): Track {
        for (const track in this.tracks) {
            this.tracks[track]?.stop(delay, options);
        }
        return this;
    }

    playSource(path: string, options?: AdjustmentOptions): AudioSource {
        return this.primaryTrack().playSource(path, options);
    }

    loadSource(path: string): AudioSource {
        return this.primaryTrack().loadSource(path);
    }

    /**
     * Adjusts the volume output of this group.
     */
    volume(volume: number, options?: AdjustmentOptions): Track {
        console.log(`stub volume changed to ${volume} with ${options}`);
        return this;
    }

    loop(enabled: boolean, startSample?: number, endSample?: number): Track {
        this.primaryTrack().loop(enabled, startSample, endSample);
        return this;
    }

    jump(enabled: boolean, fromSample?: number, toSample?: number): Track {
        this.primaryTrack().jump(enabled, fromSample, toSample);
        return this;
    }

    createBeat(type: 'repeating' | 'precise' | 'exclude', origin: number, period?: number): TrackBeat {
        return this.primaryTrack().createBeat(type, origin, period);
    }

    /**
     * Clears beats across all tracks in the group.
     */
    clearBeats(): Track {
        for (const track in this.tracks) {
            this.tracks[track]?.clearBeats();
        }
        return this;
    }

    /**
     * Synchronizes playback of all tracks in the group.
     */
    syncPlayTo(track: Track, options?: AdjustmentOptions): Track {
        for (const t in this.tracks) {
            this.tracks[t]?.syncPlayTo(track, options);
        }
        return this;
    }

    /**
     * Synchronizes stopping of all track in the group.
     */
    syncStopTo(track: Track, options?: AdjustmentOptions): Track {
        for (const t in this.tracks) {
            this.tracks[t]?.syncStopTo(track, options);
        }
        return this;
    }

    listenFor(type: TrackEventType, callback: Promise<any>): Track {
        this.primaryTrack().listenFor(type, callback);
        return this;
    }
}

export default TrackSingle;
export { Track, TrackGroup };
